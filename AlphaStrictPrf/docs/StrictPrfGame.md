# StrictPrfGameの内部仕様

# 概要

StrictPrfGameとは、形式的な文法StrictPrf(以後Prfと略す)を書き換え、テストケースを満たす語を作るゲームである。

# ゲームの説明

## 大まかな流れ

用語
- 初期語
- 入力数列
- 出力数列


ユーザは初めにPrfの初期語`Z()`とテストケースとして2つの数列(入力数列と出力数列)を与えられる。
ゲームが始まると、ユーザは与えられた語を書き換えていき、入力数列の各要素を入力したとき、出力数列の各要素を返す関数を表せたらゲーム終了であり、1ポイントを獲得する。

一方、100手以内に正解の語にたどり着けなかった場合、ゲーム失敗となり、ポイントは獲得できない。

## 書き換え操作のルール

1回の書き換え操作は、書き換えを行う場所を表す自然数のリストと、書き換え後を表すトークンに対応した語(`S()`, `Z()`, `P(i, j)`, `C(Z())`, `C(Z(), Z())`, `C(Z(), Z(), Z())`, ..., `R(Z(), Z())`) の組で`([1, 1, 2], "p_3")`のように表される。

場所を表す自然数のリスト規則を説明する。目的の部分Prfを、一番外側の関数から「第a引数の、さらに第b引数の、さらに第c引数の...」というように辿って表し、このときの引数の番号をつなげて`[a, b, c..]`というように表す。

例えば、`C(Z(), R(S(), P(1, 1)), S())`の、`P(1, 1)`を書き換えたい場合、これは`C`の2番目の引数`R`の2番目の引数なので、この場所は`[2, 2]`と表される。ちなみに、ここで`[2]`と指定すると、`R(S(), P(1, 1))`の全てが消去され、新し語に書き変わる

次に、書き換え後の語の種類について説明する。ゲームには予めMAX_P_ARITY, EXPR_DEPTH, MAX_C_ARGS という3つの数が決まっており、ゲーム中には変わらない。この数を使って、以下のように書き換え後の語の種類が決まる。 
- `Z()`
- `S()`
- `P(i, j)` (ただし、MAX_P_ARITY >= i >= j)
- `C(Z(), Z(), Z(), ..., Z())` (ただし、引数の数iはMAX_C_ARGSを超えない)
- `R(Z(), Z())`

### 書き換え操作の例

ゲーム内の値が以下のように決まっており、
```
MAX_P_ARITY = 2
EXPR_DEPTH = 2
MAX_C_ARGS = 3
```
現在のユーザの語が`C(Z(), R(S(), P(1, 1)), S())`のときにできる操作を考えてみる。

書き換え場所は以下のよう。
- `[]`
- `[1]`
- `[2]`
- `[2, 1]`
- `[2, 2]`
- `[3]`
書き換え先の語は以下のよう
- `Z()`
- `S()`
- `P(1, 1)`
- `P(2, 1) `
- `P(2, 2)`
- `C(Z(), Z()) `
- `C(Z(), Z(), Z())`
- `R(Z(), Z())`
よって、8x6で48通りの操作が行えることになる。

## 操作の種類と式を変更するか

上から順に報酬が低い
- 指定した場所にノードがない → 式の変更無し
- ノードを書き換えると定義できない式になる → 式の変更あり
- ノードを書き換えたらarityが1ではない式 → 式の変更あり
- ノードを書き換えたらarityが1の式になる → 式の変更あり
- ノードを書き換えたら正解の式になる → 式の変更あり





## 探索範囲の上限
MAX_P_ARITY: 探索における射影作用素Pのarityの最大
EXPR_DEPTH: 探索における式の構造の深さの最大
MAX_C_ARGS: 探索におけるCの取る引数の数 (C(X1, X2, ..., Xn)のn)



